#include <Eigen/Dense>
#include <Eigen/SVD>
#include <Eigen/Sparse>

#include "GCore/Components/MeshOperand.h"
#include "Nodes/node.hpp"
#include "Nodes/node_declare.hpp"
#include "Nodes/node_register.h"
#include "geom_node_base.h"
#include "utils/util_openmesh_bind.h"

/*
** @brief HW5_ARAP_Parameterization
**
** This file presents the basic framework of a "node", which processes inputs
** received from the left and outputs specific variables for downstream nodes to
** use.
**
** - In the first function, node_declare, you can set up the node's input and
** output variables.
**
** - The second function, node_exec is the execution part of the node, where we
** need to implement the node's functionality.
**
** - The third function generates the node's registration information, which
** eventually allows placing this node in the GUI interface.
**
** Your task is to fill in the required logic at the specified locations
** within this template, especially in node_exec.
*/

namespace USTC_CG::node_arap {
static void node_arap_declare(NodeDeclarationBuilder& b)
{
    // Input-1: Original 3D mesh with boundary
    // Maybe you need to add another input for initialization?
    b.add_input<decl::Geometry>("Input");
    // Initialized input that has UV coordinates generated by min surface process.
    b.add_input<decl::Int>("Iteration Times").min(0).max(10).default_val(1);

    /*
    ** NOTE: You can add more inputs or outputs if necessary. For example, in
    ** some cases, additional information (e.g. other mesh geometry, other
    ** parameters) is required to perform the computation.
    **
    ** Be sure that the input/outputs do not share the same name. You can add
    ** one geometry as
    **
    **                b.add_input<decl::Geometry>("Input");
    **
    ** Or maybe you need a value buffer like:
    **
    **                b.add_input<decl::Float1Buffer>("Weights");
    */

    // Output-1: The UV coordinate of the mesh, provided by ARAP algorithm
    b.add_output<decl::Float2Buffer>("TexCoords");
    // Output-2: The flattened image of the mesh, provided by ARAP algorithm
    b.add_output<decl::Geometry>("OutputMesh");
    // Output-3: The flattened image of the mesh, provided by ARAP algorithm
    b.add_output<decl::Geometry>("FlattenedMesh");
}

static void node_arap_exec(ExeParams params)
{
    // Get the input from params
    auto input = params.get_input<GOperandBase>("Input");
    int iteration_times = params.get_input<int>("Iteration Times");

    // Avoid processing the node when there is no input
    if (!input.get_component<MeshComponent>()) {
        throw std::runtime_error("Need Geometry Input.");
    }
    // throw std::runtime_error("Not implemented");

    /* ----------------------------- Preprocess -------------------------------
    ** Create a halfedge structure (using OpenMesh) for the input mesh. The
    ** half-edge data structure is a widely used data structure in geometric
    ** processing, offering convenient operations for traversing and modifying
    ** mesh elements.
    */
    auto halfedge_mesh = operand_to_openmesh(&input);

    /* ------------- [HW5_TODO] ARAP Parameterization Implementation -----------
    ** Implement ARAP mesh parameterization to minimize local distortion.
    **
    ** Steps:
    ** 1. Initial Setup: Use a HW4 parameterization result as initial setup.
    **
    ** 2. Local Phase: For each triangle, compute local orthogonal approximation
    **    (Lt) by computing SVD of Jacobian(Jt) with fixed u.
    **
    ** 3. Global Phase: With Lt fixed, update parameter coordinates(u) by solving
    **    a pre-factored global sparse linear system.
    **
    ** 4. Iteration: Repeat Steps 2 and 3 to refine parameterization.
    **
    ** Note:
    **  - Fixed points' selection is crucial for ARAP and ASAP.
    **  - Encapsulate algorithms into classes for modularity.
    */
    // We have variables: u for each vertex, L for each triangle.
    std::vector<Eigen::Vector2f> u(halfedge_mesh->n_vertices());
    std::vector<Eigen::Matrix2f> L(halfedge_mesh->n_faces());
    // Initialize u with the UV coordinates from Input.
    for (int i = 0; i < halfedge_mesh->n_vertices(); i++) {
        u[i] = Eigen::Vector2f(input.get_component<MeshComponent>()->texcoordsArray[i].data());
    }
    // u.assign(
    //     input.get_component<MeshComponent>()->texcoordsArray.begin(),
    //     input.get_component<MeshComponent>()->texcoordsArray.end());

    // Step 1-Initial Setup: Use a HW4 parameterization result as initial setup.
    // This step is implemented by giving initialized input.

    // Prestep 1: Implement a piecewise linear mapping from 3D mesh to 2D plane. It may be
    // seperated pieces. It serves as a way to know the relative position of the vertices in the
    // 2D plane. In ARAP and ASAP, rotation is allowed, so we can rotate the pieces.
    std::vector<std::vector<std::pair<int, Eigen::Vector2f>>> x(halfedge_mesh->n_faces());
    for (auto face_handle : halfedge_mesh->faces()) {
        const auto halfedge_handle = face_handle.halfedges().begin().handle();
        const auto ver1 = halfedge_handle.to();
        const auto ver2 = halfedge_handle.next().to();
        const auto ver3 = halfedge_handle.next().next().to();
        const auto point1 = halfedge_mesh->point(ver1);
        const auto point2 = halfedge_mesh->point(ver2);
        const auto point3 = halfedge_mesh->point(ver3);
        x[face_handle.idx()].push_back(std::make_pair(ver1.idx(), Eigen::Vector2f(0, 0)));
        x[face_handle.idx()].push_back(
            std::make_pair(ver2.idx(), Eigen::Vector2f((point2 - point1).norm(), 0)));
        const float theta = acos(
            (point2 - point1).dot(point3 - point1) /
            ((point2 - point1).norm() * (point3 - point1).norm()));
        x[face_handle.idx()].push_back(std::make_pair(
            ver3.idx(),
            Eigen::Vector2f(
                (point3 - point1).norm() * cos(theta), (point3 - point1).norm() * sin(theta))));
    }

    // Prestep 2: Have the global sparse linear system pre-factored.
    // Solve the equations: Sum_{j \in N(i)} (cot(\theta_ij) + cot(\theta_ji)) * (u_i - u_j) =
    // Sum_{j \in N(i)} (cot(\theta_ij) L_t(i, j) + cot(\theta_ji) L_t(j, i)) * (x_i - x_j), where
    // N(i) is the set of neighbors of i, \theta_ij is the angle that is opposite to the edge (i, j)
    // in surface t, L_t(i, j) is L in the surface t that contains the halfedge (i, j).
    // This equation depends only on x and structure of the mesh, so we can pre-factored it.
    Eigen::SparseMatrix<float> A(halfedge_mesh->n_vertices(), halfedge_mesh->n_vertices());
    std::vector<Eigen::Triplet<float>> triplets;
    Eigen::MatrixXf b = Eigen::MatrixXf::Zero(halfedge_mesh->n_vertices(), 2);
    Eigen::SparseLU<Eigen::SparseMatrix<float>> solver;
    // Calculate A and b.
    for (auto vertex_handle : halfedge_mesh->vertices()) {
        for (auto halfedge_handle : vertex_handle.outgoing_halfedges()) {
            const int from = vertex_handle.idx();
            const int to = halfedge_handle.to().idx();
            const OpenMesh::SmartFaceHandle face[2] = { halfedge_handle.face(),
                                                        halfedge_handle.opp().face() };
            float cot[2] = { 0.0f, 0.0f };
            for (int i = 0; i < 2; i++) {
                if (face[i].is_valid()) {
                    for (int j = 0; j < 3; j++) {
                        int k = (j + 1) % 3;
                        if ((x[face[i].idx()][j].first == from &&
                             x[face[i].idx()][k].first == to) ||
                            (x[face[i].idx()][j].first == to &&
                             x[face[i].idx()][k].first == from)) {
                            int l = (j + 2) % 3;
                            cot[i] =
                                1 /
                                tan(acos(((x[face[i].idx()][j].second - x[face[i].idx()][l].second)
                                              .normalized())
                                             .dot(((x[face[i].idx()][k].second -
                                                    x[face[i].idx()][l].second)
                                                       .normalized()))));
                            break;
                        }
                    }
                }
            }
            triplets.push_back(Eigen::Triplet<float>(from, from, cot[0] + cot[1]));
            triplets.push_back(Eigen::Triplet<float>(from, to, -cot[0] - cot[1]));
        }
    }
    A.setFromTriplets(triplets.begin(), triplets.end());
    // Fix two points.
    auto fixed_edge = halfedge_mesh->edges_begin()->halfedge();
    int fixed_face_idx = fixed_edge.face().idx();
    const int fixed1 = fixed_edge.from().idx();
    const int fixed2 = fixed_edge.to().idx();
    for (int i = 0; i < halfedge_mesh->n_vertices(); i++) {
        if (i != fixed1) {
            A.coeffRef(fixed1, i) = 0;
        }
        else {
            A.coeffRef(fixed1, i) = 1;
        }
    }
    for (int i = 0; i < halfedge_mesh->n_vertices(); i++) {
        if (i != fixed2) {
            A.coeffRef(fixed2, i) = 0;
        }
        else {
            A.coeffRef(fixed2, i) = 1;
        }
    }

    solver.compute(A);
    if (solver.info() != Eigen::Success) {
        throw std::runtime_error("Decomposition failed.");
    }

    // We will iterate the following steps.
    while (iteration_times-- > 0) {
        // Step 2-Local Phase: For each triangle, compute local orthogonal approximation (Lt) by
        // computing SVD of Jacobian(Jt) with fixed u.

        // Equivalently, use "cross-covariance matrix" S_t(u) instead of J_t(u).
        // S_t(u) = Sum_{i=0}^{2} cot(\theta_t^i) (u_t^i - u_t^{i+1}) (x_t^i - x_t^{i+1})^T
        // SVD decompose S_t(u) = U_t * Sigma_t * V_t^T. The best Lt = U_t * V_t^T.
        for (auto face_handle : halfedge_mesh->faces()) {
            const auto halfedge_handle = face_handle.halfedges().begin().handle();
            const auto ver1 = halfedge_handle.to();
            const auto ver2 = halfedge_handle.next().to();
            const auto ver3 = halfedge_handle.next().next().to();
            const auto x1 = x[face_handle.idx()][0].second;
            const auto x2 = x[face_handle.idx()][1].second;
            const auto x3 = x[face_handle.idx()][2].second;
            const auto u1 = u[ver1.idx()];
            const auto u2 = u[ver2.idx()];
            const auto u3 = u[ver3.idx()];
            const float cot1 = 1 / tan(acos((x2 - x1).normalized().dot(((x3 - x1).normalized()))));
            const float cot2 = 1 / tan(acos((x3 - x2).normalized().dot(((x1 - x2).normalized()))));
            const float cot3 = 1 / tan(acos((x1 - x3).normalized().dot(((x2 - x3).normalized()))));
            // Eigen::Matrix2f S = { cot3 * (u1 - u2).XAxis() * (x1 - x2).XAxis() +
            //                           cot1 * (u2 - u3).XAxis() * (x2 - x3).XAxis() +
            //                           cot2 * (u3 - u1).XAxis() * (x3 - x1).XAxis(),
            //                       cot3 * (u1 - u2).XAxis() * (x1 - x2).YAxis() +
            //                           cot1 * (u2 - u3).XAxis() * (x2 - x3).YAxis() +
            //                           cot2 * (u3 - u1).XAxis() * (x3 - x1).YAxis(),
            //                       cot3 * (u1 - u2).YAxis() * (x1 - x2).XAxis() +
            //                           cot1 * (u2 - u3).YAxis() * (x2 - x3).XAxis() +
            //                           cot2 * (u3 - u1).YAxis() * (x3 - x1).XAxis(),
            //                       cot3 * (u1 - u2).YAxis() * (x1 - x2).YAxis() +
            //                           cot1 * (u2 - u3).YAxis() * (x2 - x3).YAxis() +
            //                           cot2 * (u3 - u1).YAxis() * (x3 - x1).YAxis() };
            Eigen::Matrix2f S = Eigen::Matrix2f::Zero();
            S += cot3 * (u1 - u2) * (x1 - x2).transpose();
            S += cot1 * (u2 - u3) * (x2 - x3).transpose();
            S += cot2 * (u3 - u1) * (x3 - x1).transpose();
            Eigen::JacobiSVD<Eigen::Matrix2f> svd(S, Eigen::ComputeFullU | Eigen::ComputeFullV);
            L[face_handle.idx()] = svd.matrixU() * svd.matrixV().transpose();
        }

        // Step 3-Global Phase: With Lt fixed, update parameter coordinates(u) by solving a
        // pre-factored global sparse linear system.

        // First set b.
        b = Eigen::MatrixXf::Zero(halfedge_mesh->n_vertices(), 2);
        for (auto vertex_handle : halfedge_mesh->vertices()) {
            for (auto halfedge_handle : vertex_handle.outgoing_halfedges()) {
                const int from = vertex_handle.idx();
                const int to = halfedge_handle.to().idx();
                const OpenMesh::SmartFaceHandle face[2] = { halfedge_handle.face(),
                                                            halfedge_handle.opp().face() };
                float cot[2];
                for (int i = 0; i < 2; i++) {
                    if (face[i].is_valid()) {
                        for (int j = 0; j < 3; j++) {
                            int k = (j + 1) % 3;
                            if ((x[face[i].idx()][j].first == from &&
                                 x[face[i].idx()][k].first == to) ||
                                (x[face[i].idx()][j].first == to &&
                                 x[face[i].idx()][k].first == from)) {
                                int l = (j + 2) % 3;
                                cot[i] = 1 / tan(acos(((x[face[i].idx()][j].second -
                                                        x[face[i].idx()][l].second)
                                                           .normalized())
                                                          .dot(((x[face[i].idx()][k].second -
                                                                 x[face[i].idx()][l].second)
                                                                    .normalized()))));
                                if (x[face[i].idx()][j].first == from) {
                                    b.row(from) +=
                                        cot[i] * L[face[i].idx()] *
                                        (x[face[i].idx()][j].second - x[face[i].idx()][k].second);
                                }
                                else {
                                    b.row(from) +=
                                        cot[i] * L[face[i].idx()] *
                                        (x[face[i].idx()][k].second - x[face[i].idx()][j].second);
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
        for (int i = 0; i < 3; i++) {
            if (x[fixed_face_idx][i].first == fixed1) {
                b.row(fixed1) = Eigen::Vector2f(
                    x[fixed_face_idx][i].second.x(), x[fixed_face_idx][i].second.y());
            }
            if (x[fixed_face_idx][i].first == fixed2) {
                b.row(fixed2) = Eigen::Vector2f(
                    x[fixed_face_idx][i].second.x(), x[fixed_face_idx][i].second.y());
            }
        }
        // Solve the linear system.
        Eigen::MatrixXf u_new = solver.solve(b);
        if (solver.info() != Eigen::Success) {
            throw std::runtime_error("Solve failed.");
        }
        // Update u.
        for (auto vertex_handle : halfedge_mesh->vertices()) {
            u[vertex_handle.idx()] = u_new.row(vertex_handle.idx());
        }
    }

    // Step 4-Iteration: Repeat Steps 2 and 3 to refine parameterization.
    // Implemented by the while loop.

    // Now we have the final u, we can output the result.
    // The result UV coordinates
    pxr::VtArray<pxr::GfVec2f> uv_result(halfedge_mesh->n_vertices());
    // uv_result.assign(u.begin(), u.end());
    for (int i = 0; i < halfedge_mesh->n_vertices(); i++) {
        uv_result.push_back(pxr::GfVec2f(u[i].x(), u[i].y()));
    }
    // The result mesh geometry
    auto operand_base = openmesh_to_operand(halfedge_mesh.get());
    auto& texcoords = operand_base->get_component<MeshComponent>()->texcoordsArray;
    texcoords.clear();
    for (int i = 0; i < halfedge_mesh->n_vertices(); i++) {
        texcoords.push_back(pxr::GfVec2f(u[i].x(), u[i].y()));
    }
    // The flattened mesh geometry
    auto flattened_mesh = openmesh_to_operand(halfedge_mesh.get());
    for (int i = 0; i < halfedge_mesh->n_vertices(); i++) {
        flattened_mesh->get_component<MeshComponent>()->vertices[i] =
            pxr::GfVec3f(u[i].x(), u[i].y(), 0);
    }

    // Set the output of the node
    params.set_output("OutputMesh", std::move(*operand_base));
    params.set_output("TexCoords", uv_result);
    params.set_output("FlattenedMesh", std::move(*flattened_mesh));
}

static void node_register()
{
    static NodeTypeInfo ntype;

    strcpy(ntype.ui_name, "ARAP Parameterization");
    strcpy_s(ntype.id_name, "geom_arap");

    geo_node_type_base(&ntype);
    ntype.node_execute = node_arap_exec;
    ntype.declare = node_arap_declare;
    nodeRegisterType(&ntype);
}

NOD_REGISTER_NODE(node_register)
}  // namespace USTC_CG::node_arap
